<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Markdown 基本语法]]></title>
      <url>%2F2017%2F04%2F24%2Fmarkdown%2F</url>
      <content type="text"><![CDATA[参考 标题123# 一级标题## 二级标题### 三级标题 一级标题二级标题三级标题 常用无序列表123* a* b* c a b c 有序列表1231. a2. b3. c a b c 表格12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 分割线1*** 或 --- 图片![description]($path) 链接[google](https://www.google.com)google 语法高亮1echo "hexo highlight" 123class Hello implements java.io.Serializable&#123; private final String world = "World!";&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[learn-jvm-3-垃圾回收]]></title>
      <url>%2F2017%2F04%2F24%2Flearn-jvm-3-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%2F</url>
      <content type="text"><![CDATA[何时进行回收一般来说，当某个区域内存不够的时候就会进行垃圾收集 如何判断一块内存是垃圾?引用计数当有对象引用自身时，就会计数器加1，删除一个引用就减一，当计数为0时即可判断为垃圾.存在的问题:引用计数存在循环引用问题 可达性分析(根搜索算法)通过一些根节点开始，分析引用链，没有被引用的对象都可以被标记为垃圾对象。JVM普遍采用该算法 GC RootsJava虚拟机将以下对象定义为 GC Roots: Java虚拟机栈中引用的对象：比如方法里面定义这种局部变量 User user= new User(); 静态属性引用的对象：比如 private static User user = new User(); 常量引用的对象：比如 private static final User user = new User(); 本地方法栈中引用的对象 引用链不可达标记即便引用链不可达，也并不意味着该对象一定会被回收，因为回收要经历两次标记过程！第一次标记：对象进行根搜索之后，如果发现没有与GC Roots 相连接的引用链，就会被第一次标记并进行筛选。所谓筛选，就是检查此对象是否有必要执行finalize方法，如果对象定义了该方法并且没有执行过。那么该对象就会被放入到一个队列F-Queue，随后会有一个低优先级的线程去执行这个队列里面对象的finalize方法第二次标记：JVM 将对F-Queue队列里面的对象进行第二次标记。如果对象不想被回收，那么就得在finalize方法里面拯救自己，否则，这些对象就真的会被回收 垃圾回收算法标记清除对非垃圾对象进行标记，清除其他的对象。存在的问题:这种方式对对内存空间造成空隙，即内存碎片，最终导致有空余空间，但没有连续的足够大小的空间分配内存。 标记整理标记非垃圾对象后，将这些对象整理好，依次排列内存。存在的问题:这样内存就是整齐的了。但是因为会造成对象移动，所以效率会有降低。~ 标记清除整理即组合标记清除和标记整理两种方式，在若干次清除后进行一次整理。 复制划分成两个相同大小的区域，收集时，将第一个区域的活对象复制到另一个区域.这样不会有内存碎片问题。但是最多只能存放一半内存,而且所有的活对象都需要拷贝。将内存分为一块较大的eden空间和2块较少的survivor空间，每次使用eden和其中一块survivor，当回收时将eden和 survivor还存活的对象一次过拷贝到另外一块survivor空间上，然后清理掉eden和用过的survivor。Sun Hotspot虚拟机默认eden和survivor的大小比例是8:1，也就是每次只有10%的内存是“浪费”的。 分代回收 对于新生代的对象回收,使用复制算法 对于老年代的对象回收,使用标记-清除算法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[interview-java基础]]></title>
      <url>%2F2017%2F04%2F23%2Finterview-java%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[多线程多线程并发访问HashMap 会造成线程死锁.(原因是并发插入会造成闭散列链表形成闭环,读线程会一直死循环在闭环里)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[interview-数据库]]></title>
      <url>%2F2017%2F04%2F23%2Finterview-%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
      <content type="text"><![CDATA[脏读 不可重复读 幻读脏读A事务访问数据并修改数据,事务未提交时B事务来读取已修改的数据.A事务回滚,放弃修改,那么B事务读到的就是脏数据 不可重复读A事务第一次读取数据(比如前10条)B事务update第1条数据,commitA事务第二次读取数据(前10条),和第一次读取有差异 幻读A事务第一次读取全部数据行(共10条)B事务insert一条数据,commitA事务第二次读取全部数据行(共11条),和第一次读取有差异 事务隔离级别 隔离级别 脏读 不可重复读 幻读 Read uncommitted (读未提交) √ √ √ Read committed (读已提交) x √ √ Repeatable read (可重复读) x x √ Serializable (可串行化) x x x 索引参考链接 聚集索引和非聚集索引 聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个 聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续. 索引的实现通常使用B树及其变种B+树。 索引的作用 唯一性索引可以保证数据库表中每一行数据的唯一性。 加快数据的检索速度，这也是创建索引的最主要的原因。 加速表和表之间的连接. 在使用分组和排序子句进行数据检索时，显著减少查询中分组和排序的时间。 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 索引不利的方面 创建索引和维护索引要耗费时间,这种时间随着数据量的增加而增加。 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 哪些列适合创建索引 在经常需要搜索的列上； 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构； 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度； 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的； 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间； 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。 哪些列不适合创建索引 对于那些在查询中很少使用或者参考的列不应该创建索引。 对于那些只有很少数据值的列也不应该增加索引。 对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。 当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[learn-jvm-4-类加载]]></title>
      <url>%2F2017%2F04%2F19%2Flearn-jvm-4-%E7%B1%BB%E5%8A%A0%E8%BD%BD%2F</url>
      <content type="text"><![CDATA[加载 验证 准备 解析 初始化 使用卸载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[learn RabbitMQ]]></title>
      <url>%2F2017%2F04%2F16%2Flearn-mq-rabbitMQ%2F</url>
      <content type="text"><![CDATA[Exchange RPC]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java并发编程--同步]]></title>
      <url>%2F2017%2F04%2F12%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B--%E5%90%8C%E6%AD%A5%2F</url>
      <content type="text"><![CDATA[线程基础Java线程状态图图片出处 sleep睡眠,放弃CPU使用,让其他线程去竞争CPU时间片.但是会持有锁. yield让步,放弃CPU使用,自己和其他进程一起参与竞争CPU时间片,会持有锁. wait释放锁并等待唤醒.如果没有设置等待时间或者,没有线程调用notify或notifyAll,那么该线程会一直在等待队列中. notify唤醒,唤醒某个等待该锁的线程.即使调用notify方法,也会等该线程退出临界区才释放锁并唤醒某个等待该锁的线程 notifyAll唤醒所有,唤醒所有等待该锁的线程,但是只要一个锁能竞争到锁,进入临界区. join加入,假如在main线程中，调用thread.join方法，则main方法会等待thread线程执行完毕或者等待一定的时间。如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待指定的时间. interrupt中断,调用interrupt方法可以使得处于阻塞状态的线程抛出一个InterruptedException，也就说，它可以用来中断一个正处于阻塞状态的线程;非阻塞的线程是无法被中断的.另外，通过interrupt方法和isInterrupted()方法来停止正在运行的线程. volatile保证线程的可见性.使用volatile必须具备以下2个条件： 1)对变量的写操作不依赖于当前值. 2)该变量没有包含在具有其他变量的不变式中 可重入锁 同步器]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[小算法练习]]></title>
      <url>%2F2017%2F04%2F09%2F%E5%B0%8F%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[链表翻转1234567891011121314node *head;node *h=head;node *hn=head-&gt;next;node *hnn=hn-&gt;next;head-&gt;next =NULL;while(hn != NULL)&#123; hn-&gt;next =h; h= hn; hn = hnn; hnn = hnn-&gt;next;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[learn-java-NIO]]></title>
      <url>%2F2017%2F04%2F08%2Flearn-java-NIO%2F</url>
      <content type="text"><![CDATA[参考http://ifeve.com/overview/ Buffer Channel Selector Pipe]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[learn-jvm-2-BTrace初探]]></title>
      <url>%2F2017%2F03%2F11%2Flearn-jvm-2-BTrace%E5%88%9D%E6%8E%A2%2F</url>
      <content type="text"><![CDATA[参考资料 Btrace入门到熟练小工完全指南 git - BTrace 环境准备 jdk 1.8 jvisualvm 安装BTrace插件 Atom 用来写BTrace脚本,别用写字板写 BTrace的基本知识参考Btrace入门到熟练小工完全指南 计算方法调用过程时间利用@Duration来获取方法调用时间, 顺便验证Array和HashMap在较少量数据下,哪个容器查找更快. 测试代码123456789101112131415161718192021222324252627282930313233public class BtraceDuration &#123; private static final int size = 400; private static Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); private static int[] arr = new int[size]; static &#123; for (int i = 0; i &lt; size; i++) &#123; map.put(i, i); arr[i] = i; &#125; &#125; public static boolean findInMap(int v) &#123; return map.get(v) != null; &#125; public static boolean findInArr(int v) &#123; for (int i : arr) &#123; if (i == v) return true; &#125; return false; &#125; public static void main(String[] args) throws IOException &#123; Scanner scanner = new Scanner(System.in); int input; while (true) &#123; input = scanner.nextInt(); // 用于阻塞程序,便于观察 findInArr(input); findInMap(input); &#125; &#125;&#125; BTrace代码123456789101112131415import com.sun.btrace.annotations.*;import static com.sun.btrace.BTraceUtils.*;@BTracepublic class TracingScript &#123;@OnMethod(clazz = "/cn.stq.learn.jvm.btrace\\..*/", method = "/find.*/", location = @Location(Kind.RETURN))public static void testDuration(@ProbeClassName String pcn,@ProbeMethodName String pmn, @Duration long duration, @Return boolean result) &#123; // duration 是纳秒,除以1000000得毫秒 print(strcat(pcn,"#")); print(strcat(pmn, ": ")); print(strcat(str(duration), "ns ")); println(strcat("result-&gt;", str(result)));&#125;&#125; 结果 谁调用了这个函数测试代码见计算方法调用过程时间的测试代码 BTrace代码12345678910111213import com.sun.btrace.annotations.*;import static com.sun.btrace.BTraceUtils.*;@BTracepublic class TracingScript &#123; @OnMethod(clazz = "/cn.stq.learn.jvm.btrace\\..*/", method = "/find.*/") public static void testInvokeStack(@ProbeClassName String pcn,@ProbeMethodName String pmn, int param) &#123; print(strcat(pcn,"#")); println(strcat(pmn, "")); println(strcat("param:", str(param))); jstack(); // 打印调用栈 &#125;&#125; 结果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[learn-jvm-1-内存分配与回收策略实战]]></title>
      <url>%2F2017%2F03%2F08%2Flearn-jvm-1-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5%E5%AE%9E%E6%88%98%2F</url>
      <content type="text"><![CDATA[参考资料 Java Garbage Collection Basics JVM参数释义 Debug环境笔者是在IDEA + jvm调试工具环境下调试. 虚拟机启动参数配置 123456-XX：+PrintGCDetails --虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况。-Xms20M --初始堆大小-Xmx20M --最大堆大小-Xmn10M --年轻代大小-XX:+UseSerialGC --指定垃圾回收器为串行垃圾回收器-XX:PretenureSizeThreshold=3145728 --超过阀值(3MB)直接分配到老年代,只对Serial和ParNew两款收集器有效 常用调试命令 12查看虚拟机唯一ID(Local Virtual Machine Identifier,LVMID),通常情况下与进程ID是一个值&gt; jps 1234查看堆栈信息&gt; jmap&gt; jmap -heap $LVMID //查看堆内存&gt; jmap -dump:format=b,file=xx.bin $LVMID //生成dump文件, 可用jhat命令分析生成的内存镜像文件 123456789101112131415161718192021222324查看堆栈内存变化信息&gt; jstat&gt; jstat -gcutil -h 20 $LVMID 500 1000 // (每隔20行显示表头,每隔500ms显示一次,一共显示1000次)option 可选 -gcnew -gcnewcapacity -gcold -gcoldcapacity -gcpermcapacity -gcutil表头含义(https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html)-gcutil optionSummary of garbage collection statistics.S0: Survivor space 0 utilization as a percentage of the space&apos;s current capacity.S1: Survivor space 1 utilization as a percentage of the space&apos;s current capacity.E: Eden space utilization as a percentage of the space&apos;s current capacity.O: Old space utilization as a percentage of the space&apos;s current capacity.M: Metaspace utilization as a percentage of the space&apos;s current capacity.CCS: Compressed class space utilization as a percentage.YGC: Number of young generation GC events.YGCT: Young generation garbage collection time.FGC: Number of full GC events.FGCT: Full garbage collection time.GCT: Total garbage collection time. 内存分配与回收策略对象优先在Eden分配1234567891011121314151617181920212223242526public class TestAllocation &#123; public static int _1MB = 1024 * 1024; /** * 测试垃圾回收 * jvm添加参数:-Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails * -Xms20M --初始堆大小 * -Xmx20M --最大堆大小 * -Xmn10M --年轻代大小 * 这3个参数限制了Java堆大小为20MB,不可扩展,其中10MB分配给新生代,剩下的10MB分配给老年代。 * -XX:SurvivorRatio=8 决定了新生代中Eden区与一个Survivor区的空间比例是8:1 * -XX:+PrintGCDetails 告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况。 */ public static void test_3_6_1()&#123; byte[] a1 = new byte[2 * _1MB]; byte[] a2 = new byte[2 * _1MB]; byte[] a3 = new byte[2 * _1MB]; byte[] a4 = new byte[_1MB &gt;&gt; 1]; a1 = null; a2 = null; a3 = null; byte[] a5 = new byte[_1MB &gt;&gt; 2];//第一次发生Minor GC (YGC) &#125; public static void main(String[] args)&#123; test_3_6_1(); &#125;&#125; 调试到第一次发生YGC的地方,GC导致的内存占用变化如下图所示. 直接分配大对象到老年代123456789101112131415161718public class Test_3_6_2 &#123; public static int _1MB = 1024 * 1024; /** * 测试直接分配大对象到老年代 * jvm添加参数:-Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:+UseSerialGC -XX:PretenureSizeThreshold=3145728 * -Xms20M --初始堆大小 * -Xmx20M --最大堆大小 * -Xmn10M --年轻代大小 * -XX:+UseSerialGC --指定垃圾回收器为串行垃圾回收器 * -XX:PretenureSizeThreshold=3145728 --超过阀值(3MB)直接分配到老年代,只对Serial和ParNew两款收集器有效 */ public static void test_3_6_2()&#123; byte[] b = new byte[4* _1MB]; //直接分配到老年代 &#125; public static void main(String[] args)&#123; test_3_6_2(); &#125;&#125; 内存占用变化如下图所示. 长期存活的对象进入老年代123456789101112131415161718192021222324252627282930313233public class Test_3_6_3 &#123; public static int _1MB = 1024 * 1024; /** * 测试长期存活的对象进入老年代 * jvm添加参数:-Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:MaxTenuringThreshold=1 -XX:+PrintTenuringDistribution * -Xms20M --初始堆大小 * -Xmx20M --最大堆大小 * -Xmn10M --年轻代大小 * -XX:MaxTenuringThreshold=1 -- 对象转移到老年代阀值(每次垃圾回收对象age+1,age大于阀值时对象被移到老年代中) * -XX:+PrintTenuringDistribution */ public static void test_3_6_3()&#123; byte[] a1 = new byte[_1MB &gt;&gt; 2]; byte[] a2 = new byte[2 * _1MB]; byte[] a3 = new byte[2 * _1MB]; byte[] a4 = new byte[2 * _1MB]; a2 = null; a3 = null; a4 = null; a2 = new byte[2 * _1MB];//第1次YGC a3 = new byte[2 * _1MB]; a4 = new byte[2 * _1MB]; a2 = null; a3 = null; a4 = null; a2 = new byte[2 * _1MB];//第2次YGC,a1被移到老年代 &#125; public static void main(String[] args)&#123; test_3_6_3(); &#125;&#125; 内存占用变化如下图所示. 第2次YDC后堆内存信息 动态对象年龄判定123456789101112131415161718192021222324252627282930public class Test_3_6_4 &#123; public static int _1MB = 1024 * 1024; /** * 测试动态对象年龄判定 * * 为了能更好地适应不同程序的内存状况， * 虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代， * 如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半， * 年龄大于或等于该年龄的对象就可以直接进入老年代， * 无须等到MaxTenuringThreshold中要求的年龄。 * * jvm添加参数:-Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:MaxTenuringThreshold=15 -XX:+PrintTenuringDistribution * -Xms20M --初始堆大小 * -Xmx20M --最大堆大小 * -Xmn10M --年轻代大小 * -XX:MaxTenuringThreshold=1 -- 对象转移到老年代阀值(每次垃圾回收对象age+1,age大于阀值时对象被移到老年代中) * -XX:+PrintTenuringDistribution */ public static void test_3_6_4()&#123; byte[] a1 = new byte[_1MB &gt;&gt; 2]; byte[] a2 = new byte[_1MB &gt;&gt; 2];//a1+a2大于survivo空间一半 byte[] a3 = new byte[3 * _1MB]; byte[] a4 = new byte[3 * _1MB]; a4 = null; byte[] a5 = new byte[2 * _1MB];//此时发生YGC, a1+a2 --&gt; S0, a3 --&gt; old &#125; public static void main(String[] args)&#123; test_3_6_4(); &#125;&#125; 内存占用变化如下图所示. 空间分配担保12345678910111213141516171819202122public class Test_3_6_5 &#123; public static int _1MB = 1024 * 1024; /** * 测试空间分配担保 * * 当出现大量对象在Minor GC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活）， * 就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代. * * jvm添加参数:-Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails * -Xms20M --初始堆大小 * -Xmx20M --最大堆大小 * -Xmn10M --年轻代大小 */ public static void test_3_6_5()&#123; byte[] a1 = new byte[ 4 * _1MB ]; byte[] a2 = new byte[ 4 * _1MB ]; byte[] a3 = new byte[ 3 * _1MB];//没有GC, 直接在老年代分配空间给a3 &#125; public static void main(String[] args)&#123; test_3_6_5(); &#125;&#125; 内存占用变化如下图所示.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[learn-jvm-0-运行时数据区域]]></title>
      <url>%2F2017%2F03%2F08%2Flearn-jvm-0-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%2F</url>
      <content type="text"><![CDATA[共享数据区域 Method Area方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来.对于习惯在HotSpot虚拟机上开发、部署程序的开发者来说，很多人都更愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已，这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。 运行时常量池运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern（）方法。 HeapJava堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。所有的对象实例以及数组都要在堆上分配[1]，但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换[2]优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”. 线程私有数据区域 PC程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 VM Stack虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame[1]）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。 Native Method Stack本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PL/SQL基础]]></title>
      <url>%2F2017%2F03%2F07%2Flearn-pl-sql%2F</url>
      <content type="text"><![CDATA[数据准备123456789101112131415161718DROP TABLE students;create table students( ID int, userName varchar(100), userPass varchar(100), userAge int);-- 插入10条DECLARE i number(2);BEGIN for i in 1..10 loop INSERT INTO students VALUES(i,'jack'||i,'jj',20+i); end loop;END;SELECT * from students; 语法基础if123456789101112DECLARE i number(1) := 5; j number(2) := 10;BEGIN if i &lt; 5 then DBMS_OUTPUT.PUT_LINE('i&lt;5'); elsif i=5 then DBMS_OUTPUT.PUT_LINE('i=5'); else DBMS_OUTPUT.PUT_LINE('i=5'); end if;END; case when1234567891011121314151617181920DECLARE i number(1) := 5; j number(2);BEGIN j:= case i when 0 then 0 when 5 then 5 else 10 end; DBMS_OUTPUT.PUT_LINE(j); j := case when i &lt; 5 then 0 when i=5 then 6 else 10 end; DBMS_OUTPUT.PUT_LINE(j);END; loop123456789DECLARE i number(1) := 0;BEGIN loop i := i + 1; DBMS_OUTPUT.PUT_LINE(i); exit when i = 5; end loop;END; while12345678DECLARE i number(2) := 0;BEGIN while i &lt; 10 loop DBMS_OUTPUT.PUT_LINE(i); i := i + 1; end loop;END; for..in12345BEGIN for i in 0..9 loop DBMS_OUTPUT.PUT_LINE(i); end loop;END; goto12345678910111213DECLARE i number(2) := 0; j number(2) := 0;BEGIN for j in 0..9 loop i := i + 1; if i=5 then goto EXIT_LOOP; end if; end loop; &lt;&lt;EXIT_LOOP&gt;&gt; DBMS_OUTPUT.PUT_LINE(i);END; 获取插入语句的返回值. 可以获取增删改返回的数据12345678910DECLARE row_id ROWID; info VARCHAR2(200);BEGIN INSERT INTO students VALUES(1,'jack','jj',23) returning rowid,to_char(ID)||':'||userName INTO row_id,info; DBMS_OUTPUT.PUT_LINE('rowid:'||row_id); DBMS_OUTPUT.PUT_LINE('name:'||info);END; 自定数据类型1234567891011DECLARE TYPE RECORD_TYPE_PERSON_AGE IS RECORD( uName varchar(100), age students.userAge%TYPE --用%TYPE 类型定义与表相配的字段 ); userRec RECORD_TYPE_PERSON_AGE;BEGIN SELECT userName,userAge INTO userRec from STUDENTS where ID=1; userRec.uName := 'changed'; DBMS_OUTPUT.PUT_LINE(userRec.uName||' '||userRec.age);END; 数组类型1234567891011121314151617DECLARE --定义一个最多保存5个VARCHAR(25)数据类型成员的VARRAY数据类型 TYPE reg_varray_type IS VARRAY(5) OF VARCHAR(25); v_reg_varray REG_VARRAY_TYPE;BEGIN --用构造函数语法赋予初值 v_reg_varray := reg_varray_type('1', '2', '3', '4', '5'); DBMS_OUTPUT.PUT_LINE(v_reg_varray(1)||',' ||v_reg_varray(2)||',' ||v_reg_varray(3)||',' ||v_reg_varray(4)); DBMS_OUTPUT.PUT_LINE(v_reg_varray(5)); --用构造函数语法赋予初值后就可以这样对成员赋值 v_reg_varray(5) := 'xx'; DBMS_OUTPUT.PUT_LINE('5th is '||v_reg_varray(5));END; 行类型, 使用%ROWTYPE1234567DECLARE vId students.ID%TYPE := 1; -- 属性类型引用 rec students%ROWTYPE; --行类型BEGIN SELECT * INTO rec FROM students where ID=vId; DBMS_OUTPUT.PUT_LINE('姓名:'||rec.userName||' 年龄:'||rec.userAge);END; 定义表类型, 使用 TABLE123456789101112DECLARE TYPE TABLE_STUDENTS IS TABLE OF STUDENTS%ROWTYPE INDEX BY BINARY_INTEGER; recs_students TABLE_STUDENTS; loop_count number(1) := 2;BEGIN FOR i IN 1..loop_count LOOP SELECT * into recs_students(i) from STUDENTS where id=i; END LOOP; FOR j IN recs_students.FIRST..recs_students.LAST LOOP DBMS_OUTPUT.PUT_LINE(recs_students(j).userName||' '||recs_students(j).ID); END LOOP;END; 游标游标基础12345678910111213141516171819/* Cursor_name%FOUND 布尔型属性，当最近一次提取游标操作FETCH成功则为 TRUE,否则为FALSE； Cursor_name%NOTFOUND 布尔型属性，与%FOUND相反； Cursor_name%ISOPEN 布尔型属性，当游标已打开时返回 TRUE； Cursor_name%ROWCOUNT 数字型属性，返回已从游标中读取的记录数。*/DECLARE cursor some_stu_cursor is SELECT ID,userName from students; userId students.ID%TYPE; userName students.userName%TYPE;BEGIN open some_stu_cursor; loop fetch some_stu_cursor into userId,userName; exit when some_stu_cursor%notfound; --取不到数据,则退出循环. DBMS_OUTPUT.PUT_LINE('id:'||userId||' name:'||userName); end loop; close some_stu_cursor;END; 游标传递参数123456789101112131415161718192021DECLARE cursor some_stu_cursor(id_no number DEFAULT 5) is SELECT ID,userName from students where id &lt;= id_no; userId students.ID%TYPE; userName students.userName%TYPE; rec students%rowtype;BEGIN --隐含打开游标 for rec in some_stu_cursor(2) LOOP --隐含执行一个FETCH语句 DBMS_OUTPUT.PUT_LINE('id:'||rec.id ||' name:'||rec.userName ); --隐含监测c_sal%NOTFOUND end loop; DBMS_OUTPUT.PUT_LINE('======================'); open some_stu_cursor(id_no =&gt; 6); loop fetch some_stu_cursor into userId,userName; exit when some_stu_cursor%notfound; --取不到数据,则退出循环. DBMS_OUTPUT.PUT_LINE('id:'||userId||' name:'||userName); end loop; close some_stu_cursor;END; ## 游标指定当前行12345678910DECLARE userId STUDENTS.ID%type; i number(2) := 1; cursor all_stu is SELECT id,userName from students FOR UPDATE;BEGIN for userId in all_stu loop update students set id=i where CURRENT of all_stu;--当前行 i := i+1; end loop;END; 游标变量12345678910111213DECLARE type ID_NAME_REC is RECORD(id STUDENTS.id%type,name students.USERNAME%type); type ID_NAME_CURSOR is REF CURSOR RETURN ID_NAME_REC; rec ID_NAME_REC; cur ID_NAME_CURSOR;BEGIN OPEN cur for SELECT id,username from students; loop --用for .. loop 不行. FETCH cur into rec; EXIT when cur%notfound; DBMS_OUTPUT.PUT_LINE('id:'||rec.id||' name:'||rec.name); end loop;END; 游标变量 - 没有return123456789101112DECLARE userId students.ID%TYPE; type REF_CURSOR is ref cursor; var_cur REF_CURSOR;BEGIN open var_cur for SELECT id from students where id &gt; 5; loop --用for .. loop 不行. FETCH var_cur into userid; EXIT when var_cur%notfound; DBMS_OUTPUT.PUT_LINE('id:'||userid); end loop;END;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Effective java 读书笔记]]></title>
      <url>%2F2017%2F02%2F09%2Feffective-java-read-note%2F</url>
      <content type="text"><![CDATA[目录 chapter02 - 创建和销毁对象 第1条:考虑用静态工厂方法替代构造器(Factory method) 第2条:遇到多个构造器参数时,要考虑用构建器(Builder) 第3条:用私有构造器或者枚举类型强化单例属性(Singleton) 第4条:通过私有构造器强化不可实例化的能力 第5条:避免创建不必要的对象 第6条:消除过期的对象引用 第7条:避免使用终结方法(finalizer) chapter03 - 对所有对象都通用的方法 第8条:覆盖equals时请遵守通用约定 第9条 覆盖equals时总要覆盖hashCode 第10条 始终要覆盖toString 第11条 谨慎使用clone 第12条 考虑实现Comparable接口 chapter04 - 类和接口 第13条 使类和成员的可访问性最小化 第14条 在公有类中使用访问方法而非公有域 第15条 使可变性最小化 第16条 复合优先于继承 第17条 要么为继承而设计，并提供文档说明，要么就禁止继承 第18条 接口优于抽象类 第19条 接口只用于定义类型 第20条 类层次优于标签类 第21条 用函数对象表示策略 第22条 优先考虑静态成员类 chapter05 - 泛型 第23条 请不要在新代码中使用原生态类型 第24条 消除非受检警告 第25条 列表优先于数组 第26条 优先考虑泛型 第27条 优先考虑泛型方法 第28条 利用有限制通配符来提升API的灵活性 第29条 优先考虑类型安全的异构容器 chapter06 - 枚举和注解 第30条 用enum代替int常量 第31条 用实例域代替序数 第32条 用EnumSet代替位域 第33条 用EnumMap代替序数索引 第34条 用接口模拟可伸缩的枚举 第35条 注解优先于命名模式 第36条 坚持使用Override注解 第37条 用标记接口定义类型 chapter07 - 方法 第38条 检查参数的有效性 第39条 必要时进行保护性拷贝 第40条 谨慎设计方法签名 第41条 慎用重载 第42条 慎用可变参数 第43条 返回零长度的数组或者集合，而不是null 第44条 为所有导出的API元素编写文档注释 chapter08 - 通用程序设计 第45条 将局部变量的作用域最小化 第46条 for-each循环优先于传统的for循环 第47条 了解和使用类库 第48条 如果需要精确的答案，请避免使用float和double 第49条 基本类型优先于装箱基本类型 第50条 如果其他类型更适合，则尽量避免使用字符串 第51条 当心字符串连接的性能 第52条 通过接口引用对象 第53条 接口优先于反射机制 第54条 谨慎地使用本地方法 第55条 谨慎地进行优化 第56条 遵守普遍接受的命名惯例 chapter09 - 异常 第57条 只针对异常的情况才使用异常 第58条 对可恢复的情况使用受检异常，对编程错误使用运行时异常 第59条 避免不必要地使用受检的异常 第60条 优先使用标准的异常 第61条 抛出与抽象相对应的异常 第62条 每个方法抛出的异常都要有文档 第63条 在细节消息中包含能捕获失败的信息 第64条 努力使失败保持原子性 第65条 不要忽略异常 chapter10 - 并发 第66条 同步访问共享的可变数据 第66条 同步访问共享的可变数据 第67条 避免过度同步 第68条 executor和task优先于线程 第69条 并发工具优先于wait和notify 第70条 线程安全性的文档化 第71条 慎用延迟初始化 第72条 不要依赖于线程调度器 第73条 避免使用线程组 chapter11 - 序列化 第74条 谨慎地实现Serializable接口 第75条 考虑使用自定义的序列化形式 第76条 保护性地编写readObject方法 第77条 对于实例控制，枚举类型优先于readResolve 第78条 考虑用序列化代理代替序列化实例 chapter03 对所有对象都通用的方法 第8条 覆盖equals时请遵守通用约定实现高质量equals方法的诀窍 使用==操作符检查”参数是否为这个对象的应用” 使用instanceof操作符检查”参数是否为正确的类型” 把参数传递转换成正确的类型 对于该类中的每个关键域,检查参数中的域是否与该对象中对应域项匹配 写完equals方法之后,应该问自己三个问题:它是否对称的,传递的,一致的?(记住Point(x,y)和ColorPoint(x,y,color)的例子) 覆写equals的告诫 覆写equals时总要覆写hashCode(见第9条) 不要企图让equals方法过于智能 不要将equals方法参数声明中的Object对象替换为其他类型. equals示例12345678910111213141516171819202122232425262728293031public final class PhoneNumber &#123; boolean booleanF; byte byteF; char charF; short shortF; int intf; float floatf; double doublef; Object objectF; Object[] arrayF; /*由IDEA自动生成*/ @Override public boolean equals(Object o) &#123; if (this == o) return true; if (!(o instanceof MyObject)) return false; MyObject myObject = (MyObject) o; if (booleanF != myObject.booleanF) return false; if (byteF != myObject.byteF) return false; if (charF != myObject.charF) return false; if (shortF != myObject.shortF) return false; if (intf != myObject.intf) return false; if (Float.compare(myObject.floatf, floatf) != 0) return false; if (Double.compare(myObject.doublef, doublef) != 0) return false; if (!objectF.equals(myObject.objectF)) return false; // Probably incorrect - comparing Object[] arrays with Arrays.equals return Arrays.equals(arrayF, myObject.arrayF); &#125;&#125; 第9条 覆盖equals时总要覆盖hashCodeObject规范[JavaSE6] 在应用程序的执行期间,只要对象的equals方法的比较操作所用到的信息没有被修改,那么对这同一个对象调用多次,hashCode方法必须始终如一地返回同一个整数.在同一个应用程序的多次执行过程中,每次执行返回的整数可以不一致. 如果两个对象根据equals方法比较结果是相等的,那么调用者两个对象中任意对象的hashCode方法都必须产生同样的整数结果. 如果两个对象根据equals方法比较结果是不相等的,那么调用这两个对象任意对象的hashCode方法,则不一定要产生不同的整数结果.总结1equals等 =&gt; hashcode等; equals不等 ≠&gt; hashcode不等 覆写hashCode方法的简单办法1234567891011121314151617181920212223242526272829public class MyObject &#123; boolean booleanF; byte byteF; char charF; short shortF; int intf; float floatf; double doublef; Object objectF; Object[] arrayF; /*由IDEA自动生成,使用Equals中涉及到的每个域*/ @Override public int hashCode() &#123; int result; long temp; result = (booleanF ? 1 : 0); result = 31 * result + (int) byteF; result = 31 * result + (int) charF; result = 31 * result + (int) shortF; result = 31 * result + intf; result = 31 * result + (floatf != +0.0f ? Float.floatToIntBits(floatf) : 0); temp = Double.doubleToLongBits(doublef); result = 31 * result + (int) (temp ^ (temp &gt;&gt;&gt; 32)); result = 31 * result + objectF.hashCode(); result = 31 * result + Arrays.hashCode(arrayF); return result; &#125;&#125; 第11条 谨慎使用clone深拷贝简单例子12345678910111213141516171819202122232425262728293031323334ublic class CloneObject implements Cloneable&#123; Object[] elememts = new Integer[]&#123;1,23,4&#125;; Integer anInt = 1; List&lt;String&gt; list = new LinkedList&lt;&gt;(Arrays.asList("1","2")); @Override public CloneObject clone() &#123; try &#123; CloneObject clone = (CloneObject) super.clone(); clone.anInt = new Integer(this.anInt); //深拷贝 clone.elememts = this.elememts.clone(); clone.list =(List&lt;String&gt;) ((LinkedList&lt;String&gt;)list).clone(); //浅拷贝 for (int i=0; list != null &amp;&amp; i&lt;list.size() ; ++i)&#123; clone.list.set(i, new String(list.get(i))); //new String对String对象深拷贝. &#125; return clone; &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return null; &#125; public static void main(String[] args) &#123; CloneObject a = new CloneObject(); CloneObject b = a.clone(); System.out.println(a==b); //false System.out.println(a.anInt == b.anInt); //false System.out.println(a.elememts == b.elememts); //false System.out.println(a.list == b.list); //false System.out.println(a.list.get(0) == b.list.get(0)); //false &#125;&#125; chapter04 类和接口 第23条 请不要在新代码中使用原生态类型12345678910111213141516//参数化类型,表示可以包含人和对象类型的集合//有受检异常 List&lt;Object&gt; list = new ArrayList&lt;&gt;();list.add(new String("a"));Integer b = list.get(0);//受检异常//通配符类型,表示只能包含某种位置对象类型的集合//有受检异常 List&lt;Object&gt; list = new ArrayList&lt;&gt;();list.add(new String("a"));//受检异常//原生态类型,脱离了泛型系统//运行时异常Set s = new HashSet();s.add(new String("str"));Integer a = (Integer)list.get(0); //java.lang.ClassCastException chapter09 异常 第60条 优先使用标准的异常]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL基础-ORACLE]]></title>
      <url>%2F2017%2F02%2F08%2Flearn-oracle%2F</url>
      <content type="text"><![CDATA[元数据查询12--1.查看表字段名SELECT * FROM all_tab_columns where TABLE_name='CCS_LOAN'; 正则表达式123456789101112131415--1,REGEXP_LIKE--默认是大小写敏感的--REGEXP_LIKE(ACCT_TYPE,'E','i')是大小写不敏感SELECT ACCT_NBR from CCS_ACCTwhere REGEXP_LIKE(ACCT_NBR,'1$');--2,REGEXP_INSTR--查找第一次出现匹配模式是indexSELECT REGEXP_INSTR(112233,'233') from dual;--3,REGEXP_SUBSTR--查找匹配的字串SELECT REGEXP_SUBSTR(112233,'[1-2]*') from dual;--4,REGEXP_REPLACE--替换匹配字串的值SELECT REGEXP_REPLACE(112233,'1&#123;2&#125;','aa') from dual; 集合操作1234567891011121314151617181920212223--1,合集;UNION (去重),UNION ALL(不去重)--UNION(SELECT ACCT_NBR from CCS_ACCT c WHERE REGEXP_LIKE(ACCT_NBR,'0$'))UNION(SELECT ACCT_NBR from CCS_ACCT c WHERE REGEXP_LIKE(ACCT_NBR,'10$'));--UNION ALL(SELECT ACCT_NBR from CCS_ACCT c WHERE REGEXP_LIKE(ACCT_NBR,'0$'))UNION ALL(SELECT ACCT_NBR from CCS_ACCT c WHERE REGEXP_LIKE(ACCT_NBR,'10$'));--2,交集; INTERSECT(SELECT ACCT_NBR from CCS_ACCT c WHERE REGEXP_LIKE(ACCT_NBR,'0$'))INTERSECT(SELECT ACCT_NBR from CCS_ACCT c WHERE REGEXP_LIKE(ACCT_NBR,'10$'));--3.差集. MINUS(SELECT ACCT_NBR from CCS_ACCT c WHERE REGEXP_LIKE(ACCT_NBR,'0$'))MINUS(SELECT ACCT_NBR from CCS_ACCT c WHERE REGEXP_LIKE(ACCT_NBR,'10$')); 字符串操作1234567891011121314151617181920212223--1.字符串拼接;concat,ORACLE只能拼接两个fieldSELECT concat('a','b') from dual;--2.字符串长度,lengthSELECT length('aaa') from dual;--3.字符串比较select case when 'aa'&lt;'ab' then 'true' else 'false' end as result from dual;--4.字符串裁剪SELECT SUBSTR('123456789',1,4) from dual;--5.长度不足左右填充; lpad,rpad ,长度不足则填充,长度够则截取指定长度.SELECT lpad('1234',10,'*'),lpad('1234',2,'*') from dual;--6.左右删除;LTRIM,RTRIMselect RTRIM('00111333111','(0|1)'),LTRIM('00111333111','(0|1)') from dual;--7.字符串替换;REPLACESELECT REPLACE('123','2','a') from dual;--8.查找第一次出现的位置select INSTR('abcdc', 'c')from dual; 时间日期操作123456789101112131415161718192021222324--1.系统时间,时间戳SELECT sysdate,SYSTIMESTAMP,CURRENT_DATEfrom dual;--2.字符串转日期SELECT TO_DATE('2016-12-06 20:15:30','yyyy-mm-dd hh24:mi:ss'),TO_DATE('20161206','yyyy-mm-dd'),cast('11:15:30'as time)from dual;--3.日期转字符串, 获取年月日,季度.SELECT to_char(sysdate,'yyyy-mm') from dual;SELECT to_char(sysdate,'q') from dual;SELECT extract(YEAR from sysdate),sysdate from dual;--取出时间中的YearSELECT extract(MONTH from sysdate),sysdate from dual;--取出时间中的MonthSELECT extract(DAY from sysdate),sysdate from dual;--取出时间中的Day--4.日期增加select sysdate,add_months(sysdate,12) from dual; --加1年select sysdate,add_months(sysdate,1) from dual; --加1月select sysdate,to_char(sysdate+7,'yyyy-mm-dd HH24:MI:SS') from dual; --加1星期select sysdate,to_char(sysdate+1,'yyyy-mm-dd HH24:MI:SS') from dual; --加1天select sysdate,to_char(sysdate+1/24,'yyyy-mm-dd HH24:MI:SS') from dual; --加1小时select sysdate,to_char(sysdate+1/24/60,'yyyy-mm-dd HH24:MI:SS') from dual; --加1分钟select sysdate,to_char(sysdate+1/24/60/60,'yyyy-mm-dd HH24:MI:SS') from dual; --加1秒--5.日期间隔select months_between(to_date('2006-04-20','yyyy-mm-dd'),to_date('2005-05-20','yyyy-mm-dd')) mon_betw from dual; --时间间隔(月)select ceil(((to_date('2008-05-02 00:00' , 'yyyy-mm-dd hh24:mi:ss') - to_date('2008-05-01 22:58' , 'yyyy-mm-dd hh24:mi:ss'))) * 24 * 60) FROM DUAL; --间隔分钟 CAST转换操作12345--1.转换为Integerselect cast('111' as int) from dual;--2.转换为NUMBERselect cast('111.333' as NUMBER(5,2)) from dual;SELECT to_number('123') from dual; 分组操作12345--按季度分组统计select to_CHAR(a.SETUP_DATE,'yyyy-q') m,count(*)from CCS_ACCT awhere 1=1group by to_CHAR(a.SETUP_DATE,'yyyy-q'); ALL ANY EXISTS 操作符123456789101112131415--1.ALL.字段值与ALL结果集中进行比较,与每一个比较都成立,则结果为真.--与not in 差别. 下面的例子,ALL将返回结果集,not in返回空集.SELECT * from CCS_ACCTWHERE ACCT_NBR &lt;&gt; ALL(SELECT ACCT_NBR from CCS_ACCT where ACCT_NBR in (1123000,1123001,NULL));SELECT * from CCS_ACCTWHERE ACCT_NBR not in (1123000,1123001,NULL);--2.Any,字段值与any结果集中进行比较,只要有一个成立,则结果为真.SELECT * from CCS_ACCTWHERE CURR_BAL &gt; any(SELECT CURR_BAL from CCS_ACCT where ROWNUM&lt;5)--3.EXISTSSELECT sysdate from dual where EXISTS(select 1 from dual where 1=1);SELECT sysdate from dual where EXISTS(select 1 from dual where 1&lt;&gt;1); trunc、round、ceil/floor123456789101112131415161718192021222324252627282930313233343536373839--1.trunc函数--trunc函数处理数字 TRUNC(number[,decimals])select trunc(123.89,0) from dual; -- 123select trunc(123.123,2) from dual; --123.12select trunc(123.123,-1) from dual; --120--trunc函数处理日期 TRUNC(date,[fmt]), sysdate为2017-02-15 10:30:09SELECT trunc(sysdate,'yyyy'),sysdate from dual; --返回当年第一天. 2017-01-01 00:00:00SELECT trunc(sysdate,'mm'),sysdate from dual; --返回当月第一天. 2017-02-01 00:00:00SELECT trunc(sysdate,'d'),sysdate from dual; --返回当前星期的第一天. 2017-02-12 00:00:00SELECT trunc(sysdate,'dd') from dual; --截取到当天0点0分0秒,2018-08-25 00:00:00SELECT trunc(sysdate,'hh24') from dual; --截取到小时（当前小时，零分零秒）,2018-08-25 04:00:00SELECT trunc(sysdate,'mi') from dual; --截取到分（当前分，零秒）2018-08-25 04:28:00SELECT trunc(sysdate,'ss') from dual ;--报错，没有精确到秒的格式--2.round 函数--round函数处理数字 round( number, [ decimal_places ] ), decimal_places为保留的小数位数--传回一个数值，该数值是按照指定的小数位元数进行四舍五入运算的结果。select round(123.456, 0) from dual; --回传 123select round(123.456, 1) from dual; --回传 123.5select round(-123.456, 2) from dual; --回传 -123.46--round函数处理日期 round(date,fmt) ,fmt为四舍五入的单位.--月select round(to_date('20170215','yyyymmdd'),'mm') from dual; -- 2017-02-01select round(to_date('20170216','yyyymmdd'),'mm') from dual; -- 2017-03-01--日select round(to_date('20170215 11:20','yyyymmdd hh24:mi'),'dd') from dual; -- 2017-02-15 00:00:00select round(to_date('20170215 12:20','yyyymmdd hh24:mi'),'dd') from dual; -- 2017-02-16 00:00:00--小时select round(to_date('20170215 11:20','yyyymmdd hh24:mi'),'hh') from dual; -- 2017-02-15 11:00:00select round(to_date('20170215 11:30','yyyymmdd hh24:mi'),'hh') from dual; -- 2017-02-15 12:00:00--3.ceil/floor 函数--处理数字select ceil(123.456) from dual; --回传 124select floor(123.456) from dual; --回传 123--处理日期select ceil(to_date('20170215 11:00','yyyymmdd hh24:mi') - to_date('20170214 11:00','yyyymmdd hh24:mi')) from dual; -- return 1select ceil(to_date('20170215 11:00','yyyymmdd hh24:mi') - to_date('20170214 10:59','yyyymmdd hh24:mi')) from dual; -- return 2select floor(to_date('20170215 11:00','yyyymmdd hh24:mi') - to_date('20170214 10:59','yyyymmdd hh24:mi')) from dual; -- return 1 常用函数123456789101112131415--1.NVL NVL2 NULLIF--NVL(e1,e2), 相当于 e1 != NULL ? e1 : e2SELECT NVL(NULL,'0'), NVL('123','1') from dual;--NVL(field,e1,e2) 相当于 field != NULL ? e1:e2SELECT NVL2(NULL,'not-null','null'),NVL2('a','not-null','null') from dual;--NULLIF(e1,e2), 相当于 e1==e2 ? NULL : e1SELECT NULLIF('a','a'),NULLIF('a','b'),NULLIF('b','a') from dual;--2. (+)的使用,哪边有（+）哪边就允许为空SELECT a.*, b.* from a,b where a.ID(+) = b.ID ; --就是一个右连接，等同于select a.*, b.* from a right join b on a.ID=b.IDSELECT a.*, b.* from a,b where a.ID = b.ID (+); --就是一个左连接，等同于select a.*, b.* from a left join b on a.ID=b.ID--3. decodeSELECT decode('a','a',96,'b',97) from dual; -- 96SELECT decode('b','a',96,'b',97) from dual; -- 97]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[善用佳软]]></title>
      <url>%2F2017%2F02%2F06%2Fnice-software%2F</url>
      <content type="text"><![CDATA[工欲善其事必先利其器. IDE IDEA - Java开发利器 压缩 7-zip - 开源精简 文档 Atom 1234567推荐插件: (autocomplete-json), (format-sql,&quot;SQL格式化&quot;), (highlight-selected,&quot;高亮当前选中字符&quot;), (minimap,&quot;代码小视图&quot;), (pretty-json,&quot;JSON格式化&quot;), (split-diff,&quot;代码对比&quot;) Notepad++ 剪切板 Ditto - 攻城狮强烈推荐使用 文件管理 Total Commander - 学习成本较大 Clover - 简单易用 EveryThing - 高效,支持正则,模糊搜索. Listary - 不仅支持文件搜索,而且支持启动应用 To-do Wunderlist - 多终端同步 系统维护 CCleaner - 小巧 绿鹰文件解锁粉碎器 - 绿色便捷 梯子 Lantern 思维导图 百度脑图 XMind]]></content>
    </entry>

    
  
  
</search>
